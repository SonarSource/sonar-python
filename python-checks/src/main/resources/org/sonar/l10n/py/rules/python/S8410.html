<p>This rule raises an issue when FastAPI route handler parameters use <code>Depends()</code>, <code>Query()</code>, <code>Path()</code>,
<code>Body()</code>, or similar dependency injection functions as default parameter values instead of within <code>Annotated</code> type hints.</p>
<h2>Why is this an issue?</h2>
<p>FastAPI originally allowed declaring dependencies by using them as default parameter values. While this approach still works, it has several
drawbacks that make code harder to maintain and understand.</p>
<p>When dependencies are declared as default values, the actual type of the parameter becomes ambiguous. For example, <code>db =
Depends(get_db)</code> doesn’t clearly indicate what type <code>db</code> will be at runtime. This makes the code harder to read and reduces the
effectiveness of IDE autocompletion and type checking tools.</p>
<p>The modern <code>Annotated</code> syntax separates the type information from the dependency declaration, making both aspects explicit. This
approach provides better clarity about what the parameter actually is, while still specifying how it should be injected.</p>
<p>Using <code>Annotated</code> consistently across your codebase also aligns with FastAPI’s current recommendations and ensures your code follows
modern Python typing conventions introduced in Python 3.9.</p>
<p>The old syntax mixes concerns by using the default value mechanism for dependency injection, which is semantically confusing since the "default"
isn’t really a default value in the traditional sense.</p>
<h3>What is the potential impact?</h3>
<p>Using the deprecated syntax makes code less maintainable in several ways:</p>
<ul>
  <li> Type checkers and IDEs cannot accurately infer the actual runtime type of parameters, reducing the effectiveness of static analysis and
  autocompletion </li>
  <li> Developers reading the code must mentally separate the dependency injection mechanism from the actual parameter type </li>
  <li> Mixing old and new syntax across a codebase creates inconsistency that increases cognitive load </li>
  <li> Future FastAPI versions may deprecate or remove support for the old syntax, requiring migration work </li>
</ul>
<h2>How to fix it in FastAPI</h2>
<p>Replace dependency declarations in default values with <code>Annotated</code> type hints. Import <code>Annotated</code> from the
<code>typing</code> module (Python 3.9+) or <code>typing_extensions</code> (Python 3.8 and earlier). The first argument to <code>Annotated</code> is
the actual type of the parameter, and the second argument is the dependency injection specification.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id="1" data-diff-type="noncompliant">
from fastapi import Depends, FastAPI

app = FastAPI()

def get_db():
    return "database_connection"

@app.get("/items/")
def read_items(db = Depends(get_db)):  # Noncompliant
    return {"db": db}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id="1" data-diff-type="compliant">
from typing import Annotated
from fastapi import Depends, FastAPI

app = FastAPI()

def get_db():
    return "database_connection"

@app.get("/items/")
def read_items(db: Annotated[str, Depends(get_db)]):
    return {"db": db}
</pre>
<p>The same pattern applies to query parameters, path parameters, and request body parameters. Use <code>Annotated</code> to combine the type with the
parameter specification.</p>
<h4>Noncompliant code example</h4>
<pre data-diff-id="2" data-diff-type="noncompliant">
from fastapi import FastAPI, Query

app = FastAPI()

@app.get("/search/")
def search_items(
    q: str = Query(None, max_length=50)  # Noncompliant
):
    return {"query": q}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id="2" data-diff-type="compliant">
from typing import Annotated
from fastapi import FastAPI, Query

app = FastAPI()

@app.get("/search/")
def search_items(
    q: Annotated[str | None, Query(max_length=50)] = None
):
    return {"query": q}
</pre>
<p>For complex dependencies that return specific types, specify the return type explicitly in the <code>Annotated</code> declaration to improve type
safety.</p>
<h4>Noncompliant code example</h4>
<pre data-diff-id="3" data-diff-type="noncompliant">
from fastapi import Depends, FastAPI

app = FastAPI()

async def common_parameters(q: str | None = None, skip: int = 0):
    return {"q": q, "skip": skip}

@app.get("/items/")
async def read_items(commons: dict = Depends(common_parameters)):  # Noncompliant
    return commons
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id="3" data-diff-type="compliant">
from typing import Annotated
from fastapi import Depends, FastAPI

app = FastAPI()

async def common_parameters(q: str | None = None, skip: int = 0):
    return {"q": q, "skip": skip}

@app.get("/items/")
async def read_items(commons: Annotated[dict, Depends(common_parameters)]):
    return commons
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> FastAPI Documentation - Dependencies - <a href="https://fastapi.tiangolo.com/tutorial/dependencies/">Official FastAPI documentation on
  dependency injection</a> </li>
  <li> FastAPI Documentation - Annotated Dependencies - <a href="https://fastapi.tiangolo.com/tutorial/dependencies/#use-annotated-in-fastapi">FastAPI
  guide on using Annotated for dependencies</a> </li>
  <li> Python typing.Annotated - <a href="https://docs.python.org/3/library/typing.html#typing.Annotated">Python documentation for the Annotated type
  hint</a> </li>
</ul>

