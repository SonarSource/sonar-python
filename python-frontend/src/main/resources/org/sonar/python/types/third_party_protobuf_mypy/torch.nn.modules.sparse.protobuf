
torch.nn.modules.sparseä
	Embedding!torch.nn.modules.sparse.Embedding"torch.nn.modules.module.Module*Ž
__init__*torch.nn.modules.sparse.Embedding.__init__"
None*P
selfF
!torch.nn.modules.sparse.Embedding"!torch.nn.modules.sparse.Embedding*0
num_embeddings
builtins.int"builtins.int*/
embedding_dim
builtins.int"builtins.int*W
padding_idxD
Union[builtins.int,None]
builtins.int"builtins.int
None *Z
max_normJ
Union[builtins.float,None] 
builtins.float"builtins.float
None *1
	norm_type 
builtins.float"builtins.float *8
scale_grad_by_freq
builtins.bool"builtins.bool *,
sparse
builtins.bool"builtins.bool *k
_weight\
 Union[torch._tensor.Tensor,None],
torch._tensor.Tensor"torch._tensor.Tensor
None *-
_freeze
builtins.bool"builtins.bool *
device
Any *
dtype
Any *¢
reset_parameters2torch.nn.modules.sparse.Embedding.reset_parameters"
None*P
selfF
!torch.nn.modules.sparse.Embedding"!torch.nn.modules.sparse.Embedding*¸
_fill_padding_idx_with_zero=torch.nn.modules.sparse.Embedding._fill_padding_idx_with_zero"
None*P
selfF
!torch.nn.modules.sparse.Embedding"!torch.nn.modules.sparse.Embedding*í
forward)torch.nn.modules.sparse.Embedding.forward",
torch._tensor.Tensor"torch._tensor.Tensor*P
selfF
!torch.nn.modules.sparse.Embedding"!torch.nn.modules.sparse.Embedding*7
input,
torch._tensor.Tensor"torch._tensor.Tensor*ª

extra_repr,torch.nn.modules.sparse.Embedding.extra_repr"
builtins.str"builtins.str*P
selfF
!torch.nn.modules.sparse.Embedding"!torch.nn.modules.sparse.Embedding*Ø
from_pretrained1torch.nn.modules.sparse.Embedding.from_pretrained*
cls*

embeddings*
freeze *
padding_idx *
max_norm *
	norm_type *
scale_grad_by_freq *
sparse 0:classmethodprŒ
__constants__/torch.nn.modules.sparse.Embedding.__constants__J
builtins.list[builtins.str]
builtins.str"builtins.str"builtins.listr`
num_embeddings0torch.nn.modules.sparse.Embedding.num_embeddings
builtins.int"builtins.intr^
embedding_dim/torch.nn.modules.sparse.Embedding.embedding_dim
builtins.int"builtins.intr‚
padding_idx-torch.nn.modules.sparse.Embedding.padding_idxD
Union[builtins.int,None]
builtins.int"builtins.int
Noner‚
max_norm*torch.nn.modules.sparse.Embedding.max_normJ
Union[builtins.float,None] 
builtins.float"builtins.float
NonerZ
	norm_type+torch.nn.modules.sparse.Embedding.norm_type 
builtins.float"builtins.floatrj
scale_grad_by_freq4torch.nn.modules.sparse.Embedding.scale_grad_by_freq
builtins.bool"builtins.boolr`
weight(torch.nn.modules.sparse.Embedding.weight,
torch._tensor.Tensor"torch._tensor.TensorrR
freeze(torch.nn.modules.sparse.Embedding.freeze
builtins.bool"builtins.boolrR
sparse(torch.nn.modules.sparse.Embedding.sparse
builtins.bool"builtins.bool¹
EmbeddingBag$torch.nn.modules.sparse.EmbeddingBag"torch.nn.modules.module.Module*Í
__init__-torch.nn.modules.sparse.EmbeddingBag.__init__"
None*V
selfL
$torch.nn.modules.sparse.EmbeddingBag"$torch.nn.modules.sparse.EmbeddingBag*0
num_embeddings
builtins.int"builtins.int*/
embedding_dim
builtins.int"builtins.int*Z
max_normJ
Union[builtins.float,None] 
builtins.float"builtins.float
None *1
	norm_type 
builtins.float"builtins.float *8
scale_grad_by_freq
builtins.bool"builtins.bool *(
mode
builtins.str"builtins.str *,
sparse
builtins.bool"builtins.bool *k
_weight\
 Union[torch._tensor.Tensor,None],
torch._tensor.Tensor"torch._tensor.Tensor
None *9
include_last_offset
builtins.bool"builtins.bool *W
padding_idxD
Union[builtins.int,None]
builtins.int"builtins.int
None *
device
Any *
dtype
Any *«
reset_parameters5torch.nn.modules.sparse.EmbeddingBag.reset_parameters"
None*V
selfL
$torch.nn.modules.sparse.EmbeddingBag"$torch.nn.modules.sparse.EmbeddingBag*Á
_fill_padding_idx_with_zero@torch.nn.modules.sparse.EmbeddingBag._fill_padding_idx_with_zero"
None*V
selfL
$torch.nn.modules.sparse.EmbeddingBag"$torch.nn.modules.sparse.EmbeddingBag*Û
forward,torch.nn.modules.sparse.EmbeddingBag.forward",
torch._tensor.Tensor"torch._tensor.Tensor*V
selfL
$torch.nn.modules.sparse.EmbeddingBag"$torch.nn.modules.sparse.EmbeddingBag*7
input,
torch._tensor.Tensor"torch._tensor.Tensor*k
offsets\
 Union[torch._tensor.Tensor,None],
torch._tensor.Tensor"torch._tensor.Tensor
None *v
per_sample_weights\
 Union[torch._tensor.Tensor,None],
torch._tensor.Tensor"torch._tensor.Tensor
None *³

extra_repr/torch.nn.modules.sparse.EmbeddingBag.extra_repr"
builtins.str"builtins.str*V
selfL
$torch.nn.modules.sparse.EmbeddingBag"$torch.nn.modules.sparse.EmbeddingBag*Ö
from_pretrained4torch.nn.modules.sparse.EmbeddingBag.from_pretrained"L
$torch.nn.modules.sparse.EmbeddingBag"$torch.nn.modules.sparse.EmbeddingBag*Œ
cls‚
*Type[torch.nn.modules.sparse.EmbeddingBag]L
$torch.nn.modules.sparse.EmbeddingBag"$torch.nn.modules.sparse.EmbeddingBag"type*<

embeddings,
torch._tensor.Tensor"torch._tensor.Tensor*,
freeze
builtins.bool"builtins.bool *Z
max_normJ
Union[builtins.float,None] 
builtins.float"builtins.float
None *1
	norm_type 
builtins.float"builtins.float *8
scale_grad_by_freq
builtins.bool"builtins.bool *(
mode
builtins.str"builtins.str *,
sparse
builtins.bool"builtins.bool *9
include_last_offset
builtins.bool"builtins.bool *W
padding_idxD
Union[builtins.int,None]
builtins.int"builtins.int
None 0:classmethodpr
__constants__2torch.nn.modules.sparse.EmbeddingBag.__constants__J
builtins.list[builtins.str]
builtins.str"builtins.str"builtins.listrc
num_embeddings3torch.nn.modules.sparse.EmbeddingBag.num_embeddings
builtins.int"builtins.intra
embedding_dim2torch.nn.modules.sparse.EmbeddingBag.embedding_dim
builtins.int"builtins.intr…
max_norm-torch.nn.modules.sparse.EmbeddingBag.max_normJ
Union[builtins.float,None] 
builtins.float"builtins.float
Noner]
	norm_type.torch.nn.modules.sparse.EmbeddingBag.norm_type 
builtins.float"builtins.floatrm
scale_grad_by_freq7torch.nn.modules.sparse.EmbeddingBag.scale_grad_by_freq
builtins.bool"builtins.boolrc
weight+torch.nn.modules.sparse.EmbeddingBag.weight,
torch._tensor.Tensor"torch._tensor.TensorrO
mode)torch.nn.modules.sparse.EmbeddingBag.mode
builtins.str"builtins.strrU
sparse+torch.nn.modules.sparse.EmbeddingBag.sparse
builtins.bool"builtins.boolro
include_last_offset8torch.nn.modules.sparse.EmbeddingBag.include_last_offset
builtins.bool"builtins.boolr…
padding_idx0torch.nn.modules.sparse.EmbeddingBag.padding_idxD
Union[builtins.int,None]
builtins.int"builtins.int
None*“
__annotations__'torch.nn.modules.sparse.__annotations__W
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dict*
Ftorch.nn.functional *v
__all__torch.nn.modules.sparse.__all__J
builtins.list[builtins.str]
builtins.str"builtins.str"builtins.list