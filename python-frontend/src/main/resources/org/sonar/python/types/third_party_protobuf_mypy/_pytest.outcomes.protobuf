
_pytest.outcomesÑ
OutcomeException!_pytest.outcomes.OutcomeException"builtins.BaseException*’
__init__*_pytest.outcomes.OutcomeException.__init__"
None*P
selfF
!_pytest.outcomes.OutcomeException"!_pytest.outcomes.OutcomeException*O
msgD
Union[builtins.str,None]
builtins.str"builtins.str
None *-
pytrace
builtins.bool"builtins.bool *ž
__repr__*_pytest.outcomes.OutcomeException.__repr__"
builtins.str"builtins.str*HF
!_pytest.outcomes.OutcomeException"!_pytest.outcomes.OutcomeExceptionr
__str__)_pytest.outcomes.OutcomeException.__str__K
CallableType[builtins.function]&
builtins.function"builtins.functionrr
msg%_pytest.outcomes.OutcomeException.msgD
Union[builtins.str,None]
builtins.str"builtins.str
NonerT
pytrace)_pytest.outcomes.OutcomeException.pytrace
builtins.bool"builtins.boolË
Skipped_pytest.outcomes.Skipped"!_pytest.outcomes.OutcomeException*ë
__init__!_pytest.outcomes.Skipped.__init__"
None*>
self4
_pytest.outcomes.Skipped"_pytest.outcomes.Skipped*O
msgD
Union[builtins.str,None]
builtins.str"builtins.str
None *-
pytrace
builtins.bool"builtins.bool *8
allow_module_level
builtins.bool"builtins.bool *8
_use_item_location
builtins.bool"builtins.bool rO

__module__#_pytest.outcomes.Skipped.__module__
builtins.str"builtins.strra
allow_module_level+_pytest.outcomes.Skipped.allow_module_level
builtins.bool"builtins.boolra
_use_item_location+_pytest.outcomes.Skipped._use_item_location
builtins.bool"builtins.bool”
Failed_pytest.outcomes.Failed"!_pytest.outcomes.OutcomeExceptionrN

__module__"_pytest.outcomes.Failed.__module__
builtins.str"builtins.strÙ
Exit_pytest.outcomes.Exit"builtins.Exception*ï
__init___pytest.outcomes.Exit.__init__"
None*8
self.
_pytest.outcomes.Exit"_pytest.outcomes.Exit*'
msg
builtins.str"builtins.str *V

returncodeD
Union[builtins.int,None]
builtins.int"builtins.int
None r>
msg_pytest.outcomes.Exit.msg
builtins.str"builtins.strrt

returncode _pytest.outcomes.Exit.returncodeD
Union[builtins.int,None]
builtins.int"builtins.int
None–
_WithException_pytest.outcomes._WithException"builtins.objectPXr°
	Exception)_pytest.outcomes._WithException.Exceptionx
_pytest.outcomes._ETX
Type[builtins.BaseException]0
builtins.BaseException"builtins.BaseException"type"typerš
__call__(_pytest.outcomes._WithException.__call__d
_pytest.outcomes._FK
CallableType[builtins.function]&
builtins.function"builtins.function<
XFailed_pytest.outcomes.XFailed"_pytest.outcomes.Failed
_with_exception _pytest.outcomes._with_exception"K
CallableType[builtins.function]&
builtins.function"builtins.function*Œ
exception_typex
_pytest.outcomes._ETX
Type[builtins.BaseException]0
builtins.BaseException"builtins.BaseException"type"type‡
_resolve_msg_to_reason'_pytest.outcomes._resolve_msg_to_reason"
builtins.str"builtins.str*+
	func_name
builtins.str"builtins.str*(
reason
builtins.str"builtins.str*O
msgD
Union[builtins.str,None]
builtins.str"builtins.str
None 
importorskip_pytest.outcomes.importorskip"
Any*)
modname
builtins.str"builtins.str*V

minversionD
Union[builtins.str,None]
builtins.str"builtins.str
None *R
reasonD
Union[builtins.str,None]
builtins.str"builtins.str
None *Œ
__annotations__ _pytest.outcomes.__annotations__W
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dict*O
TYPE_CHECKING_pytest.outcomes.TYPE_CHECKING
builtins.bool"builtins.bool*ô
TEST_OUTCOME_pytest.outcomes.TEST_OUTCOMEÄ
>Tuple[CallableType[builtins.type],CallableType[builtins.type]]?
CallableType[builtins.type]
builtins.type"builtins.type?
CallableType[builtins.type]
builtins.type"builtins.type