
sklearn.utils._available_ifÖ

MethodTypetypes.MethodType"builtins.object*Ï
__closure__types.MethodType.__closure__"Ä
'Union[builtins.tuple[types._Cell],None]I
builtins.tuple[types._Cell]
types._Cell"types._Cell"builtins.tuple
None*.
self$
types.MethodType"types.MethodType0:property`* 
__defaults__types.MethodType.__defaults__"]
Union[builtins.tuple[Any],None].
builtins.tuple[Any]
Any"builtins.tuple
None*.
self$
types.MethodType"types.MethodType0:property`*õ
__func__types.MethodType.__func__"6
types._StaticFunctionType"types._StaticFunctionType*.
self$
types.MethodType"types.MethodType0:property`*á
__self__types.MethodType.__self__""
builtins.object"builtins.object*.
self$
types.MethodType"types.MethodType0:property`*Å
__name__types.MethodType.__name__"
builtins.str"builtins.str*.
self$
types.MethodType"types.MethodType0:property`*â
__qualname__types.MethodType.__qualname__"
builtins.str"builtins.str*.
self$
types.MethodType"types.MethodType0:property`*‘
__init__types.MethodType.__init__"
None*.
self$
types.MethodType"types.MethodType*MK
CallableType[builtins.function]&
builtins.function"builtins.function*$"
builtins.object"builtins.object*Ü
__call__types.MethodType.__call__"
Any*.
self$
types.MethodType"types.MethodType*
args
Any*
kwargs
Any8µ
_AvailableIfDescriptor2sklearn.utils._available_if._AvailableIfDescriptor"builtins.object*§
__init__;sklearn.utils._available_if._AvailableIfDescriptor.__init__"
None*r
selfh
2sklearn.utils._available_if._AvailableIfDescriptor"2sklearn.utils._available_if._AvailableIfDescriptor*S
fnK
CallableType[builtins.function]&
builtins.function"builtins.function*V
checkK
CallableType[builtins.function]&
builtins.function"builtins.function*0
attribute_name
builtins.str"builtins.str*Æ
__get__:sklearn.utils._available_if._AvailableIfDescriptor.__get__"K
CallableType[builtins.function]&
builtins.function"builtins.function*r
selfh
2sklearn.utils._available_if._AvailableIfDescriptor"2sklearn.utils._available_if._AvailableIfDescriptor*
obj
Any*
owner
Any µ
wrapsfunctools.wraps"8
_typeshed.IdentityFunction"_typeshed.IdentityFunction*°
wrappedì
*TypeAlias[CallableType[builtins.function]]K
CallableType[builtins.function]&
builtins.function"builtins.function"functools._AnyCallable*^
assignedN
typing.Sequence[builtins.str]
builtins.str"builtins.str"typing.Sequence *]
updatedN
typing.Sequence[builtins.str]
builtins.str"builtins.str"typing.Sequence ®
update_wrapperfunctools.update_wrapper"E
functools._T"
builtins.object"builtins.object"builtins.object*R
wrapperE
functools._T"
builtins.object"builtins.object"builtins.object*°
wrappedì
*TypeAlias[CallableType[builtins.function]]K
CallableType[builtins.function]&
builtins.function"builtins.function"functools._AnyCallable*^
assignedN
typing.Sequence[builtins.str]
builtins.str"builtins.str"typing.Sequence *]
updatedN
typing.Sequence[builtins.str]
builtins.str"builtins.str"typing.Sequence ›
available_if(sklearn.utils._available_if.available_if"K
CallableType[builtins.function]&
builtins.function"builtins.function*V
checkK
CallableType[builtins.function]&
builtins.function"builtins.function*ó
__annotations__+sklearn.utils._available_if.__annotations__W
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dict