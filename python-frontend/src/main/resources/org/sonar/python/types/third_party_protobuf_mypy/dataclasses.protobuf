
dataclasses€ 
Typebuiltins.type"builtins.object*É
__base__builtins.type.__base__"
builtins.type"builtins.type*(
self
builtins.type"builtins.type0:builtins.property`*ã
__basicsize__builtins.type.__basicsize__"
builtins.int"builtins.int*(
self
builtins.type"builtins.type0:builtins.property`*Œ
__dict__builtins.type.__dict__"i
(types.MappingProxyType[builtins.str,Any]
builtins.str"builtins.str
Any"types.MappingProxyType*(
self
builtins.type"builtins.type0:builtins.property`*ç
__dictoffset__builtins.type.__dictoffset__"
builtins.int"builtins.int*(
self
builtins.type"builtins.type0:builtins.property`*É
	__flags__builtins.type.__flags__"
builtins.int"builtins.int*(
self
builtins.type"builtins.type0:builtins.property`*â
__itemsize__builtins.type.__itemsize__"
builtins.int"builtins.int*(
self
builtins.type"builtins.type0:builtins.property`*≤
__mro__builtins.type.__mro__"O
builtins.tuple[builtins.type]
builtins.type"builtins.type"builtins.tuple*(
self
builtins.type"builtins.type0:builtins.property`*Ω
__text_signature__ builtins.type.__text_signature__"D
Union[builtins.str,None]
builtins.str"builtins.str
None*(
self
builtins.type"builtins.type0:builtins.property`*ì
__weakrefoffset__builtins.type.__weakrefoffset__"
builtins.int"builtins.int*(
self
builtins.type"builtins.type0:builtins.property`*{
__call__builtins.type.__call__"
Any*(
self
builtins.type"builtins.type*
args
Any*
kwds
Any*˙
__subclasses__builtins.type.__subclasses__"w
builtins.list[_typeshed.Self]G
_typeshed.Self"
builtins.object"builtins.object"builtins.object"builtins.list*Q
selfG
_typeshed.Self"
builtins.object"builtins.object"builtins.object*ë
mrobuiltins.type.mro"M
builtins.list[builtins.type]
builtins.type"builtins.type"builtins.list*(
self
builtins.type"builtins.type*â
__instancecheck__builtins.type.__instancecheck__"
builtins.bool"builtins.bool*(
self
builtins.type"builtins.type*	
Any*†
__subclasscheck__builtins.type.__subclasscheck__"
builtins.bool"builtins.bool*(
self
builtins.type"builtins.type* 
builtins.type"builtins.type*ó
__prepare__builtins.type.__prepare__"Ä
,typing.Mapping[builtins.str,builtins.object]
builtins.str"builtins.str"
builtins.object"builtins.object"typing.Mapping*J
metacls=
Type[builtins.type]
builtins.type"builtins.type"type*
builtins.str"builtins.str*QO
builtins.tuple[builtins.type]
builtins.type"builtins.type"builtins.tuple*
kwds
Any0:builtins.classmethodp2Ö
__init__builtins.type.__init__ë
__init__builtins.type.__init__"
None*(
self
builtins.type"builtins.type*$"
builtins.object"builtins.object0:typing.overloadXÃ
__init__builtins.type.__init__"
None*(
self
builtins.type"builtins.type*
builtins.str"builtins.str*QO
builtins.tuple[builtins.type]
builtins.type"builtins.type"builtins.tuple*YW
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dict*
kwds
Any0:typing.overloadX2∫
__new__builtins.type.__new__√
__new__builtins.type.__new__"
builtins.type"builtins.type*F
cls=
Type[builtins.type]
builtins.type"builtins.type"type*$"
builtins.object"builtins.object0:typing.overloadX—
__new__builtins.type.__new__"G
_typeshed.Self"
builtins.object"builtins.object"builtins.object*p
clsg
Type[_typeshed.Self]G
_typeshed.Self"
builtins.object"builtins.object"builtins.object"type*
builtins.str"builtins.str*QO
builtins.tuple[builtins.type]
builtins.type"builtins.type"builtins.tuple*YW
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dict*
kwds
Any0:typing.overloadXru
	__bases__builtins.type.__bases__O
builtins.tuple[builtins.type]
builtins.type"builtins.type"builtins.tuplerD

__module__builtins.type.__module__
builtins.str"builtins.strrH
__qualname__builtins.type.__qualname__
builtins.str"builtins.str}
_MISSING_TYPEdataclasses._MISSING_TYPE"	enum.EnumHrD
MISSING!dataclasses._MISSING_TYPE.MISSING
	enum.auto"	enum.autoÈ
_DefaultFactorydataclasses._DefaultFactory"builtins.object*£
__call__$dataclasses._DefaultFactory.__call__"J
dataclasses._T_co"
builtins.object"builtins.object"builtins.object*§
selfô
.dataclasses._DefaultFactory[dataclasses._T_co]J
dataclasses._T_co"
builtins.object"builtins.object"builtins.object"dataclasses._DefaultFactoryPXﬂ
Fielddataclasses.Field"builtins.object*ì
__init__dataclasses.Field.__init__"
None*â
self
!dataclasses.Field[dataclasses._T]G
dataclasses._T"
builtins.object"builtins.object"builtins.object"dataclasses.Field*T
defaultG
dataclasses._T"
builtins.object"builtins.object"builtins.object*`
default_factoryK
CallableType[builtins.function]&
builtins.function"builtins.function*(
init
builtins.bool"builtins.bool*(
repr
builtins.bool"builtins.bool*Q
hashG
Union[builtins.bool,None]
builtins.bool"builtins.bool
None*+
compare
builtins.bool"builtins.bool*I
metadata;
typing.Mapping[Any,Any]
Any
Any"typing.Mapping*ï
__set_name__dataclasses.Field.__set_name__"
None*â
self
!dataclasses.Field[dataclasses._T]G
dataclasses._T"
builtins.object"builtins.object"builtins.object"dataclasses.Field*'
owner
	Type[Any]
Any"type*&
name
builtins.str"builtins.strPr<
namedataclasses.Field.name
builtins.str"builtins.strrá
typedataclasses.Field.typeg
Type[dataclasses._T]G
dataclasses._T"
builtins.object"builtins.object"builtins.object"typerå
defaultdataclasses.Field.defaultÂ
8Union[dataclasses._T,Literal[dataclasses._MISSING_TYPE]]G
dataclasses._T"
builtins.object"builtins.object"builtins.object^
"Literal[dataclasses._MISSING_TYPE]	6
dataclasses._MISSING_TYPE"dataclasses._MISSING_TYPErÜ
default_factory!dataclasses.Field.default_factoryœ
UUnion[dataclasses._DefaultFactory[dataclasses._T],Literal[dataclasses._MISSING_TYPE]]ì
+dataclasses._DefaultFactory[dataclasses._T]G
dataclasses._T"
builtins.object"builtins.object"builtins.object"dataclasses._DefaultFactory^
"Literal[dataclasses._MISSING_TYPE]	6
dataclasses._MISSING_TYPE"dataclasses._MISSING_TYPEr>
reprdataclasses.Field.repr
builtins.bool"builtins.boolrg
hashdataclasses.Field.hashG
Union[builtins.bool,None]
builtins.bool"builtins.bool
Noner>
initdataclasses.Field.init
builtins.bool"builtins.boolrD
comparedataclasses.Field.compare
builtins.bool"builtins.boolrs
metadatadataclasses.Field.metadataK
types.MappingProxyType[Any,Any]
Any
Any"types.MappingProxyTypeO
FrozenInstanceErrordataclasses.FrozenInstanceError"builtins.AttributeErrorÍ
_InitVarMetadataclasses._InitVarMeta"builtins.type*∞
__getitem__$dataclasses._InitVarMeta.__getitem__"8
dataclasses.InitVar[Any]
Any"dataclasses.InitVar*64
dataclasses._InitVarMeta"dataclasses._InitVarMeta*	
Anyí
InitVardataclasses.InitVar"builtins.object*∂
__init__dataclasses.InitVar.__init__"
None*é
selfÉ
#dataclasses.InitVar[dataclasses._T]G
dataclasses._T"
builtins.object"builtins.object"builtins.object"dataclasses.InitVar*q
typeg
Type[dataclasses._T]G
dataclasses._T"
builtins.object"builtins.object"builtins.object"type@Pbdataclasses._InitVarMetarâ
typedataclasses.InitVar.typeg
Type[dataclasses._T]G
dataclasses._T"
builtins.object"builtins.object"builtins.object"typeî
fieldsdataclasses.fields"n
&builtins.tuple[dataclasses.Field[Any]]4
dataclasses.Field[Any]
Any"dataclasses.Field"builtins.tuple*Ö
class_or_instanceÌ
DUnion[_typeshed.DataclassInstance,Type[_typeshed.DataclassInstance]]:
_typeshed.DataclassInstance"_typeshed.DataclassInstanceg
!Type[_typeshed.DataclassInstance]:
_typeshed.DataclassInstance"_typeshed.DataclassInstance"typeÛ
make_dataclassdataclasses.make_dataclass"
builtins.type"builtins.type**
cls_name
builtins.str"builtins.str*„
fields÷
ltyping.Iterable[Union[builtins.str,Tuple[builtins.str,builtins.type],Tuple[builtins.str,builtins.type,Any]]]‘
[Union[builtins.str,Tuple[builtins.str,builtins.type],Tuple[builtins.str,builtins.type,Any]]
builtins.str"builtins.strc
!Tuple[builtins.str,builtins.type]
builtins.str"builtins.str
builtins.type"builtins.typep
%Tuple[builtins.str,builtins.type,Any]
builtins.str"builtins.str
builtins.type"builtins.type
Any"typing.Iterable*\
basesO
builtins.tuple[builtins.type]
builtins.type"builtins.type"builtins.tuple *§
	namespaceí
+Union[builtins.dict[builtins.str,Any],None]W
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dict
None **
init
builtins.bool"builtins.bool **
repr
builtins.bool"builtins.bool *(
eq
builtins.bool"builtins.bool *+
order
builtins.bool"builtins.bool *1
unsafe_hash
builtins.bool"builtins.bool *,
frozen
builtins.bool"builtins.bool ¢
replacedataclasses.replace"t
dataclasses._DataclassT:
_typeshed.DataclassInstance"_typeshed.DataclassInstance"_typeshed.DataclassInstance*vt
dataclasses._DataclassT:
_typeshed.DataclassInstance"_typeshed.DataclassInstance"_typeshed.DataclassInstance*
changes
Any"è
asdictdataclasses.asdictœ
asdictdataclasses.asdict"W
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dict*C
obj:
_typeshed.DataclassInstance"_typeshed.DataclassInstance0:typing.overloadXû
asdictdataclasses.asdict"G
dataclasses._T"
builtins.object"builtins.object"builtins.object*C
obj:
_typeshed.DataclassInstance"_typeshed.DataclassInstance*]
dict_factoryK
CallableType[builtins.function]&
builtins.function"builtins.function0:typing.overloadX"Ì
astupledataclasses.astuple®
astupledataclasses.astuple".
builtins.tuple[Any]
Any"builtins.tuple*C
obj:
_typeshed.DataclassInstance"_typeshed.DataclassInstance0:typing.overloadX°
astupledataclasses.astuple"G
dataclasses._T"
builtins.object"builtins.object"builtins.object*C
obj:
_typeshed.DataclassInstance"_typeshed.DataclassInstance*^
tuple_factoryK
CallableType[builtins.function]&
builtins.function"builtins.function0:typing.overloadX"⁄
	dataclassdataclasses.dataclassê
	dataclassdataclasses.dataclass"K
CallableType[builtins.function]&
builtins.function"builtins.function*

None0:typing.overloadXã
	dataclassdataclasses.dataclass"g
Type[dataclasses._T]G
dataclasses._T"
builtins.object"builtins.object"builtins.object"type*ig
Type[dataclasses._T]G
dataclasses._T"
builtins.object"builtins.object"builtins.object"type0:typing.overloadXî
	dataclassdataclasses.dataclass"K
CallableType[builtins.function]&
builtins.function"builtins.function**
init
builtins.bool"builtins.bool **
repr
builtins.bool"builtins.bool *(
eq
builtins.bool"builtins.bool *+
order
builtins.bool"builtins.bool *1
unsafe_hash
builtins.bool"builtins.bool *,
frozen
builtins.bool"builtins.bool 0:typing.overloadX"ó
fielddataclasses.field™
fielddataclasses.field"G
dataclasses._T"
builtins.object"builtins.object"builtins.object*T
defaultG
dataclasses._T"
builtins.object"builtins.object"builtins.object**
init
builtins.bool"builtins.bool **
repr
builtins.bool"builtins.bool *S
hashG
Union[builtins.bool,None]
builtins.bool"builtins.bool
None *-
compare
builtins.bool"builtins.bool *~
metadatan
#Union[typing.Mapping[Any,Any],None];
typing.Mapping[Any,Any]
Any
Any"typing.Mapping
None 0:typing.overloadX∂
fielddataclasses.field"G
dataclasses._T"
builtins.object"builtins.object"builtins.object*`
default_factoryK
CallableType[builtins.function]&
builtins.function"builtins.function**
init
builtins.bool"builtins.bool **
repr
builtins.bool"builtins.bool *S
hashG
Union[builtins.bool,None]
builtins.bool"builtins.bool
None *-
compare
builtins.bool"builtins.bool *~
metadatan
#Union[typing.Mapping[Any,Any],None];
typing.Mapping[Any,Any]
Any
Any"typing.Mapping
None 0:typing.overloadXî
fielddataclasses.field"
Any**
init
builtins.bool"builtins.bool **
repr
builtins.bool"builtins.bool *S
hashG
Union[builtins.bool,None]
builtins.bool"builtins.bool
None *-
compare
builtins.bool"builtins.bool *~
metadatan
#Union[typing.Mapping[Any,Any],None];
typing.Mapping[Any,Any]
Any
Any"typing.Mapping
None 0:typing.overloadX"ˇ
is_dataclassdataclasses.is_dataclassæ
is_dataclassdataclasses.is_dataclass":
Literal[builtins.bool]	
builtins.bool"builtins.bool*C
obj:
_typeshed.DataclassInstance"_typeshed.DataclassInstance0:typing.overloadXÜ
is_dataclassdataclasses.is_dataclass"
builtins.bool"builtins.bool*'
obj
builtins.type"builtins.type0:typing.overloadXä
is_dataclassdataclasses.is_dataclass"
builtins.bool"builtins.bool*+
obj"
builtins.object"builtins.object0:typing.overloadX*á
__annotations__dataclasses.__annotations__W
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dict*j
__all__dataclasses.__all__J
builtins.list[builtins.str]
builtins.str"builtins.str"builtins.list*V
MISSINGdataclasses.MISSING6
dataclasses._MISSING_TYPE"dataclasses._MISSING_TYPE