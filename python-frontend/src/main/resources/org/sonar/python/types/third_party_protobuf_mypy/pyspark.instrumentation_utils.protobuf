
pyspark.instrumentation_utilsÖ
_wrap_function,pyspark.instrumentation_utils._wrap_function"K
CallableType[builtins.function]&
builtins.function"builtins.function*,

class_name
builtins.str"builtins.str*/
function_name
builtins.str"builtins.str*U
funcK
CallableType[builtins.function]&
builtins.function"builtins.function*
logger
AnyÎ
_wrap_property,pyspark.instrumentation_utils._wrap_property"
Any*,

class_name
builtins.str"builtins.str*/
property_name
builtins.str"builtins.str*
prop
Any*
logger
Any¹
_wrap_missing_function4pyspark.instrumentation_utils._wrap_missing_function"
Any*,

class_name
builtins.str"builtins.str*/
function_name
builtins.str"builtins.str*U
funcK
CallableType[builtins.function]&
builtins.function"builtins.function*
original
Any*
logger
AnyÞ
_wrap_missing_property4pyspark.instrumentation_utils._wrap_missing_property"
Any*,

class_name
builtins.str"builtins.str*/
property_name
builtins.str"builtins.str*
prop
Any*
logger
Anyž
_attach%pyspark.instrumentation_utils._attach"
None*
logger_modulel
$Union[builtins.str,types.ModuleType]
builtins.str"builtins.str$
types.ModuleType"types.ModuleType*c
modulesV
builtins.list[types.ModuleType]$
types.ModuleType"types.ModuleType"builtins.list*T
classesG
builtins.list[Type[Any]]
	Type[Any]
Any"type"builtins.list*¥
missings–
)builtins.list[Tuple[Type[Any],Type[Any]]]Z
Tuple[Type[Any],Type[Any]]
	Type[Any]
Any"type
	Type[Any]
Any"type"builtins.list*™
__annotations__-pyspark.instrumentation_utils.__annotations__W
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dict*|
__all__%pyspark.instrumentation_utils.__all__J
builtins.list[builtins.str]
builtins.str"builtins.str"builtins.list*R
_local$pyspark.instrumentation_utils._local"
threading.local"threading.local