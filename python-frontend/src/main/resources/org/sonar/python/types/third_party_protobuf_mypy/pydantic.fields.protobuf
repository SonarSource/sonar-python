
pydantic.fieldsîR
CollectionCountercollections.Counter"builtins.dict*ü
copycollections.Counter.copy"∑
collections.Counter.SelfÉ
#collections.Counter[collections._T]G
collections._T"
builtins.object"builtins.object"builtins.object"collections.Counter"collections.Counter*¬
self∑
collections.Counter.SelfÉ
#collections.Counter[collections._T]G
collections._T"
builtins.object"builtins.object"builtins.object"collections.Counter"collections.Counter*∂
elementscollections.Counter.elements"{
typing.Iterator[collections._T]G
collections._T"
builtins.object"builtins.object"builtins.object"typing.Iterator*é
selfÉ
#collections.Counter[collections._T]G
collections._T"
builtins.object"builtins.object"builtins.object"collections.Counter*„
most_commoncollections.Counter.most_common"“
1builtins.list[Tuple[collections._T,builtins.int]]ç
"Tuple[collections._T,builtins.int]G
collections._T"
builtins.object"builtins.object"builtins.object
builtins.int"builtins.int"builtins.list*é
selfÉ
#collections.Counter[collections._T]G
collections._T"
builtins.object"builtins.object"builtins.object"collections.Counter*M
nD
Union[builtins.int,None]
builtins.int"builtins.int
None *¸
fromkeyscollections.Counter.fromkeys"
NoReturn
*√
clsπ
)Type[collections.Counter[collections._T]]É
#collections.Counter[collections._T]G
collections._T"
builtins.object"builtins.object"builtins.object"collections.Counter"type*
iterable
Any*M
vD
Union[builtins.int,None]
builtins.int"builtins.int
None 0:builtins.classmethodp*Ø
__missing__collections.Counter.__missing__"
builtins.int"builtins.int*é
selfÉ
#collections.Counter[collections._T]G
collections._T"
builtins.object"builtins.object"builtins.object"collections.Counter*P
keyG
collections._T"
builtins.object"builtins.object"builtins.object*Á
__delitem__collections.Counter.__delitem__"
None*ÜÉ
#collections.Counter[collections._T]G
collections._T"
builtins.object"builtins.object"builtins.object"collections.Counter*$"
builtins.object"builtins.object*»
__add__collections.Counter.__add__"ç
9collections.Counter[Union[collections._T,collections._S]]∫
$Union[collections._T,collections._S]G
collections._T"
builtins.object"builtins.object"builtins.objectG
collections._S"
builtins.object"builtins.object"builtins.object"collections.Counter*ÜÉ
#collections.Counter[collections._T]G
collections._T"
builtins.object"builtins.object"builtins.object"collections.Counter*ÜÉ
#collections.Counter[collections._S]G
collections._S"
builtins.object"builtins.object"builtins.object"collections.Counter*æ
__sub__collections.Counter.__sub__"É
#collections.Counter[collections._T]G
collections._T"
builtins.object"builtins.object"builtins.object"collections.Counter*ÜÉ
#collections.Counter[collections._T]G
collections._T"
builtins.object"builtins.object"builtins.object"collections.Counter*ÜÉ
#collections.Counter[collections._T]G
collections._T"
builtins.object"builtins.object"builtins.object"collections.Counter*æ
__and__collections.Counter.__and__"É
#collections.Counter[collections._T]G
collections._T"
builtins.object"builtins.object"builtins.object"collections.Counter*ÜÉ
#collections.Counter[collections._T]G
collections._T"
builtins.object"builtins.object"builtins.object"collections.Counter*ÜÉ
#collections.Counter[collections._T]G
collections._T"
builtins.object"builtins.object"builtins.object"collections.Counter*∆
__or__collections.Counter.__or__"ç
9collections.Counter[Union[collections._T,collections._S]]∫
$Union[collections._T,collections._S]G
collections._T"
builtins.object"builtins.object"builtins.objectG
collections._S"
builtins.object"builtins.object"builtins.object"collections.Counter*ÜÉ
#collections.Counter[collections._T]G
collections._T"
builtins.object"builtins.object"builtins.object"collections.Counter*ÜÉ
#collections.Counter[collections._S]G
collections._S"
builtins.object"builtins.object"builtins.object"collections.Counter*µ
__pos__collections.Counter.__pos__"É
#collections.Counter[collections._T]G
collections._T"
builtins.object"builtins.object"builtins.object"collections.Counter*ÜÉ
#collections.Counter[collections._T]G
collections._T"
builtins.object"builtins.object"builtins.object"collections.Counter*µ
__neg__collections.Counter.__neg__"É
#collections.Counter[collections._T]G
collections._T"
builtins.object"builtins.object"builtins.object"collections.Counter*ÜÉ
#collections.Counter[collections._T]G
collections._T"
builtins.object"builtins.object"builtins.object"collections.Counter*®
__iadd__collections.Counter.__iadd__"∑
collections.Counter.SelfÉ
#collections.Counter[collections._T]G
collections._T"
builtins.object"builtins.object"builtins.object"collections.Counter"collections.Counter*∫∑
collections.Counter.SelfÉ
#collections.Counter[collections._T]G
collections._T"
builtins.object"builtins.object"builtins.object"collections.Counter"collections.Counter*ÜÉ
#collections.Counter[collections._T]G
collections._T"
builtins.object"builtins.object"builtins.object"collections.Counter*®
__isub__collections.Counter.__isub__"∑
collections.Counter.SelfÉ
#collections.Counter[collections._T]G
collections._T"
builtins.object"builtins.object"builtins.object"collections.Counter"collections.Counter*∫∑
collections.Counter.SelfÉ
#collections.Counter[collections._T]G
collections._T"
builtins.object"builtins.object"builtins.object"collections.Counter"collections.Counter*ÜÉ
#collections.Counter[collections._T]G
collections._T"
builtins.object"builtins.object"builtins.object"collections.Counter*®
__iand__collections.Counter.__iand__"∑
collections.Counter.SelfÉ
#collections.Counter[collections._T]G
collections._T"
builtins.object"builtins.object"builtins.object"collections.Counter"collections.Counter*∫∑
collections.Counter.SelfÉ
#collections.Counter[collections._T]G
collections._T"
builtins.object"builtins.object"builtins.object"collections.Counter"collections.Counter*ÜÉ
#collections.Counter[collections._T]G
collections._T"
builtins.object"builtins.object"builtins.object"collections.Counter*¶
__ior__collections.Counter.__ior__"∑
collections.Counter.SelfÉ
#collections.Counter[collections._T]G
collections._T"
builtins.object"builtins.object"builtins.object"collections.Counter"collections.Counter*∫∑
collections.Counter.SelfÉ
#collections.Counter[collections._T]G
collections._T"
builtins.object"builtins.object"builtins.object"collections.Counter"collections.Counter*ÜÉ
#collections.Counter[collections._T]G
collections._T"
builtins.object"builtins.object"builtins.object"collections.Counter2¯	
__init__collections.Counter.__init__Ê
__init__collections.Counter.__init__"
None*é
selfÉ
#collections.Counter[collections._T]G
collections._T"
builtins.object"builtins.object"builtins.object"collections.Counter*
None 0:typing.overloadX·
__init__collections.Counter.__init__"
None*`
selfV
!collections.Counter[builtins.str]
builtins.str"builtins.str"collections.Counter*
None *(
kwargs
builtins.int"builtins.int0:typing.overloadX¶
__init__collections.Counter.__init__"
None*é
selfÉ
#collections.Counter[collections._T]G
collections._T"
builtins.object"builtins.object"builtins.object"collections.Counter*À»
=_typeshed.SupportsKeysAndGetItem[collections._T,builtins.int]G
collections._T"
builtins.object"builtins.object"builtins.object
builtins.int"builtins.int" _typeshed.SupportsKeysAndGetItem0:typing.overloadX◊
__init__collections.Counter.__init__"
None*é
selfÉ
#collections.Counter[collections._T]G
collections._T"
builtins.object"builtins.object"builtins.object"collections.Counter*}{
typing.Iterable[collections._T]G
collections._T"
builtins.object"builtins.object"builtins.object"typing.Iterable0:typing.overloadX2
subtractcollections.Counter.subtractÊ
subtractcollections.Counter.subtract"
None*é
selfÉ
#collections.Counter[collections._T]G
collections._T"
builtins.object"builtins.object"builtins.object"collections.Counter*
None 0:typing.overloadXÇ
subtractcollections.Counter.subtract"
None*é
selfÉ
#collections.Counter[collections._T]G
collections._T"
builtins.object"builtins.object"builtins.object"collections.Counter*ß§
+typing.Mapping[collections._T,builtins.int]G
collections._T"
builtins.object"builtins.object"builtins.object
builtins.int"builtins.int"typing.Mapping0:typing.overloadX◊
subtractcollections.Counter.subtract"
None*é
selfÉ
#collections.Counter[collections._T]G
collections._T"
builtins.object"builtins.object"builtins.object"collections.Counter*}{
typing.Iterable[collections._T]G
collections._T"
builtins.object"builtins.object"builtins.object"typing.Iterable0:typing.overloadX2ﬁ
updatecollections.Counter.update®
updatecollections.Counter.update"
None*é
selfÉ
#collections.Counter[collections._T]G
collections._T"
builtins.object"builtins.object"builtins.object"collections.Counter*ß§
+typing.Mapping[collections._T,builtins.int]G
collections._T"
builtins.object"builtins.object"builtins.object
builtins.int"builtins.int"typing.Mapping*(
kwargs
builtins.int"builtins.int0:typing.overloadX˝
updatecollections.Counter.update"
None*é
selfÉ
#collections.Counter[collections._T]G
collections._T"
builtins.object"builtins.object"builtins.object"collections.Counter*}{
typing.Iterable[collections._T]G
collections._T"
builtins.object"builtins.object"builtins.object"typing.Iterable*(
kwargs
builtins.int"builtins.int0:typing.overloadXå
updatecollections.Counter.update"
None*é
selfÉ
#collections.Counter[collections._T]G
collections._T"
builtins.object"builtins.object"builtins.object"collections.Counter*
None *(
kwargs
builtins.int"builtins.int0:typing.overloadXP’
CollectionsHashabletyping.Hashable"builtins.object*à
__hash__typing.Hashable.__hash__"
builtins.int"builtins.int*,
self"
typing.Hashable"typing.Hashable0:abc.abstractmethod@8@Xbabc.ABCMeta
CollectionsIterabletyping.Iterable"builtins.object*∞
__iter__typing.Iterable.__iter__"w
typing.Iterator[typing._T_co]E
typing._T_co"
builtins.object"builtins.object"builtins.object"typing.Iterator*yw
typing.Iterable[typing._T_co]E
typing._T_co"
builtins.object"builtins.object"builtins.object"typing.Iterable0:abc.abstractmethod@8PXª
UndefinedTypepydantic.fields.UndefinedType"builtins.object*í
__repr__&pydantic.fields.UndefinedType.__repr__"
builtins.str"builtins.str*@>
pydantic.fields.UndefinedType"pydantic.fields.UndefinedType*‘
__copy__&pydantic.fields.UndefinedType.__copy__"J
pydantic.fields.T"
builtins.object"builtins.object"builtins.object*T
selfJ
pydantic.fields.T"
builtins.object"builtins.object"builtins.object*û

__reduce__(pydantic.fields.UndefinedType.__reduce__"
builtins.str"builtins.str*H
self>
pydantic.fields.UndefinedType"pydantic.fields.UndefinedType*Ï
__deepcopy__*pydantic.fields.UndefinedType.__deepcopy__"J
pydantic.fields.T"
builtins.object"builtins.object"builtins.object*T
selfJ
pydantic.fields.T"
builtins.object"builtins.object"builtins.object*
_
Anyã!
	FieldInfopydantic.fields.FieldInfo"pydantic.utils.Representation*ß
__init__"pydantic.fields.FieldInfo.__init__"
None*@
self6
pydantic.fields.FieldInfo"pydantic.fields.FieldInfo*
default
Any *
kwargs
Any*ú
__repr_args__'pydantic.fields.FieldInfo.__repr_args__"ü
?TypeAlias[typing.Sequence[Tuple[Union[builtins.str,None],Any]]]ø
4typing.Sequence[Tuple[Union[builtins.str,None],Any]]v
#Tuple[Union[builtins.str,None],Any]D
Union[builtins.str,None]
builtins.str"builtins.str
None
Any"typing.Sequence"pydantic.typing.ReprArgs*@
self6
pydantic.fields.FieldInfo"pydantic.fields.FieldInfo*»
get_constraints)pydantic.fields.FieldInfo.get_constraints"H
builtins.set[builtins.str]
builtins.str"builtins.str"builtins.set*@
self6
pydantic.fields.FieldInfo"pydantic.fields.FieldInfo*¯
update_from_config,pydantic.fields.FieldInfo.update_from_config"
None*@
self6
pydantic.fields.FieldInfo"pydantic.fields.FieldInfo*h
from_configW
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dict*|
	_validate#pydantic.fields.FieldInfo._validate"
None*@
self6
pydantic.fields.FieldInfo"pydantic.fields.FieldInforú	
	__slots__#pydantic.fields.FieldInfo.__slots__È
ÿTuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]
builtins.str"builtins.str
builtins.str"builtins.str
builtins.str"builtins.str
builtins.str"builtins.str
builtins.str"builtins.str
builtins.str"builtins.str
builtins.str"builtins.str
builtins.str"builtins.str
builtins.str"builtins.str
builtins.str"builtins.str
builtins.str"builtins.str
builtins.str"builtins.str
builtins.str"builtins.str
builtins.str"builtins.str
builtins.str"builtins.str
builtins.str"builtins.str
builtins.str"builtins.str
builtins.str"builtins.str
builtins.str"builtins.str
builtins.str"builtins.str
builtins.str"builtins.str
builtins.str"builtins.str
builtins.str"builtins.str
builtins.str"builtins.str
builtins.str"builtins.str
builtins.str"builtins.strr¯
__field_constraints__/pydantic.fields.FieldInfo.__field_constraints__≠
5builtins.dict[builtins.str,Union[builtins.bool,None]]
builtins.str"builtins.strG
Union[builtins.bool,None]
builtins.bool"builtins.bool
None"builtins.dictr5
default!pydantic.fields.FieldInfo.default
AnyrE
default_factory)pydantic.fields.FieldInfo.default_factory
Anyr1
aliaspydantic.fields.FieldInfo.alias
AnyrC
alias_priority(pydantic.fields.FieldInfo.alias_priority
Anyr1
titlepydantic.fields.FieldInfo.title
Anyr=
description%pydantic.fields.FieldInfo.description
Anyr5
exclude!pydantic.fields.FieldInfo.exclude
Anyr5
include!pydantic.fields.FieldInfo.include
Anyr1
constpydantic.fields.FieldInfo.const
Anyr+
gtpydantic.fields.FieldInfo.gt
Anyr+
gepydantic.fields.FieldInfo.ge
Anyr+
ltpydantic.fields.FieldInfo.lt
Anyr+
lepydantic.fields.FieldInfo.le
Anyr=
multiple_of%pydantic.fields.FieldInfo.multiple_of
Anyr;

max_digits$pydantic.fields.FieldInfo.max_digits
AnyrC
decimal_places(pydantic.fields.FieldInfo.decimal_places
Anyr9
	min_items#pydantic.fields.FieldInfo.min_items
Anyr9
	max_items#pydantic.fields.FieldInfo.max_items
Anyr?
unique_items&pydantic.fields.FieldInfo.unique_items
Anyr;

min_length$pydantic.fields.FieldInfo.min_length
Anyr;

max_length$pydantic.fields.FieldInfo.max_length
AnyrC
allow_mutation(pydantic.fields.FieldInfo.allow_mutation
Anyr1
regexpydantic.fields.FieldInfo.regex
AnyrA
discriminator'pydantic.fields.FieldInfo.discriminator
Anyr/
reprpydantic.fields.FieldInfo.repr
AnyrÅ
extrapydantic.fields.FieldInfo.extraW
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dictÕ≤

ModelFieldpydantic.fields.ModelField"pydantic.utils.Representation*ƒ

__init__#pydantic.fields.ModelField.__init__"
None*B
self8
pydantic.fields.ModelField"pydantic.fields.ModelField*&
name
builtins.str"builtins.str*'
type_
	Type[Any]
Any"type*≠
class_validatorsñ
KUnion[builtins.dict[builtins.str,pydantic.class_validators.Validator],None]∫
?builtins.dict[builtins.str,pydantic.class_validators.Validator]
builtins.str"builtins.strJ
#pydantic.class_validators.Validator"#pydantic.class_validators.Validator"builtins.dict
None*v
model_configd
 Type[pydantic.config.BaseConfig]8
pydantic.config.BaseConfig"pydantic.config.BaseConfig"type*
default
Any *¸
default_factory‰
6Union[TypeAlias[CallableType[builtins.function]],None]ù
*TypeAlias[CallableType[builtins.function]]K
CallableType[builtins.function]&
builtins.function"builtins.function" pydantic.typing.NoArgAnyCallable
None *ä
required˘
=TypeAlias[Union[builtins.bool,pydantic.fields.UndefinedType]]ñ
2Union[builtins.bool,pydantic.fields.UndefinedType]
builtins.bool"builtins.bool>
pydantic.fields.UndefinedType"pydantic.fields.UndefinedType"pydantic.fields.BoolUndefined *)
alias
builtins.str"builtins.str *}

field_infok
%Union[pydantic.fields.FieldInfo,None]6
pydantic.fields.FieldInfo"pydantic.fields.FieldInfo
None *Ç
get_default&pydantic.fields.ModelField.get_default"
Any*B
self8
pydantic.fields.ModelField"pydantic.fields.ModelField*ê
_get_field_info*pydantic.fields.ModelField._get_field_info"i
$Tuple[pydantic.fields.FieldInfo,Any]6
pydantic.fields.FieldInfo"pydantic.fields.FieldInfo
Any*,

field_name
builtins.str"builtins.str*

annotation
Any*
value
Any*p
configd
 Type[pydantic.config.BaseConfig]8
pydantic.config.BaseConfig"pydantic.config.BaseConfig"type0:builtins.staticmethodh*„
infer pydantic.fields.ModelField.infer"8
pydantic.fields.ModelField"pydantic.fields.ModelField*m
clsd
 Type[pydantic.fields.ModelField]8
pydantic.fields.ModelField"pydantic.fields.ModelField"type*&
name
builtins.str"builtins.str*
value
Any*

annotation
Any*≠
class_validatorsñ
KUnion[builtins.dict[builtins.str,pydantic.class_validators.Validator],None]∫
?builtins.dict[builtins.str,pydantic.class_validators.Validator]
builtins.str"builtins.strJ
#pydantic.class_validators.Validator"#pydantic.class_validators.Validator"builtins.dict
None*p
configd
 Type[pydantic.config.BaseConfig]8
pydantic.config.BaseConfig"pydantic.config.BaseConfig"type0:builtins.classmethodp*Û

set_config%pydantic.fields.ModelField.set_config"
None*B
self8
pydantic.fields.ModelField"pydantic.fields.ModelField*p
configd
 Type[pydantic.config.BaseConfig]8
pydantic.config.BaseConfig"pydantic.config.BaseConfig"type*¨
	alt_alias$pydantic.fields.ModelField.alt_alias"
builtins.bool"builtins.bool*B
self8
pydantic.fields.ModelField"pydantic.fields.ModelField0:builtins.property`*{
prepare"pydantic.fields.ModelField.prepare"
None*B
self8
pydantic.fields.ModelField"pydantic.fields.ModelField*ó
_set_default_and_type0pydantic.fields.ModelField._set_default_and_type"
None*B
self8
pydantic.fields.ModelField"pydantic.fields.ModelField*â
_type_analysis)pydantic.fields.ModelField._type_analysis"
None*B
self8
pydantic.fields.ModelField"pydantic.fields.ModelField*π
&prepare_discriminated_union_sub_fieldsApydantic.fields.ModelField.prepare_discriminated_union_sub_fields"
None*B
self8
pydantic.fields.ModelField"pydantic.fields.ModelField*æ
_create_sub_type+pydantic.fields.ModelField._create_sub_type"8
pydantic.fields.ModelField"pydantic.fields.ModelField*B
self8
pydantic.fields.ModelField"pydantic.fields.ModelField*'
type_
	Type[Any]
Any"type*&
name
builtins.str"builtins.str*.
for_keys
builtins.bool"builtins.bool *ì
populate_validators.pydantic.fields.ModelField.populate_validators"
None*B
self8
pydantic.fields.ModelField"pydantic.fields.ModelField*ô
validate#pydantic.fields.ModelField.validate"Ï
gTypeAlias[Tuple[Union[Any,None],Union[typing.Sequence[Any],pydantic.error_wrappers.ErrorWrapper,None]]]ﬁ
\Tuple[Union[Any,None],Union[typing.Sequence[Any],pydantic.error_wrappers.ErrorWrapper,None]]&
Union[Any,None]
Any
None”
EUnion[typing.Sequence[Any],pydantic.error_wrappers.ErrorWrapper,None]0
typing.Sequence[Any]
Any"typing.SequenceL
$pydantic.error_wrappers.ErrorWrapper"$pydantic.error_wrappers.ErrorWrapper
None"pydantic.fields.ValidateReturn*B
self8
pydantic.fields.ModelField"pydantic.fields.ModelField*
v
Any*c
valuesW
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dict*Ö
loc˚
OTypeAlias[Union[builtins.tuple[Union[builtins.int,builtins.str]],builtins.str]]ç
DUnion[builtins.tuple[Union[builtins.int,builtins.str]],builtins.str]§
0builtins.tuple[Union[builtins.int,builtins.str]]`
 Union[builtins.int,builtins.str]
builtins.int"builtins.int
builtins.str"builtins.str"builtins.tuple
builtins.str"builtins.str"pydantic.fields.LocStr*∑
cls´
NUnion[Type[pydantic.main.BaseModel],Type[pydantic.dataclasses.Dataclass],None][
Type[pydantic.main.BaseModel]2
pydantic.main.BaseModel"pydantic.main.BaseModel"typep
$Type[pydantic.dataclasses.Dataclass]@
pydantic.dataclasses.Dataclass"pydantic.dataclasses.Dataclass"type
None *µ
_validate_sequence_like2pydantic.fields.ModelField._validate_sequence_like"Ï
gTypeAlias[Tuple[Union[Any,None],Union[typing.Sequence[Any],pydantic.error_wrappers.ErrorWrapper,None]]]ﬁ
\Tuple[Union[Any,None],Union[typing.Sequence[Any],pydantic.error_wrappers.ErrorWrapper,None]]&
Union[Any,None]
Any
None”
EUnion[typing.Sequence[Any],pydantic.error_wrappers.ErrorWrapper,None]0
typing.Sequence[Any]
Any"typing.SequenceL
$pydantic.error_wrappers.ErrorWrapper"$pydantic.error_wrappers.ErrorWrapper
None"pydantic.fields.ValidateReturn*B
self8
pydantic.fields.ModelField"pydantic.fields.ModelField*
v
Any*c
valuesW
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dict*Ö
loc˚
OTypeAlias[Union[builtins.tuple[Union[builtins.int,builtins.str]],builtins.str]]ç
DUnion[builtins.tuple[Union[builtins.int,builtins.str]],builtins.str]§
0builtins.tuple[Union[builtins.int,builtins.str]]`
 Union[builtins.int,builtins.str]
builtins.int"builtins.int
builtins.str"builtins.str"builtins.tuple
builtins.str"builtins.str"pydantic.fields.LocStr*µ
cls´
NUnion[Type[pydantic.main.BaseModel],Type[pydantic.dataclasses.Dataclass],None][
Type[pydantic.main.BaseModel]2
pydantic.main.BaseModel"pydantic.main.BaseModel"typep
$Type[pydantic.dataclasses.Dataclass]@
pydantic.dataclasses.Dataclass"pydantic.dataclasses.Dataclass"type
None*´
_validate_iterable-pydantic.fields.ModelField._validate_iterable"Ï
gTypeAlias[Tuple[Union[Any,None],Union[typing.Sequence[Any],pydantic.error_wrappers.ErrorWrapper,None]]]ﬁ
\Tuple[Union[Any,None],Union[typing.Sequence[Any],pydantic.error_wrappers.ErrorWrapper,None]]&
Union[Any,None]
Any
None”
EUnion[typing.Sequence[Any],pydantic.error_wrappers.ErrorWrapper,None]0
typing.Sequence[Any]
Any"typing.SequenceL
$pydantic.error_wrappers.ErrorWrapper"$pydantic.error_wrappers.ErrorWrapper
None"pydantic.fields.ValidateReturn*B
self8
pydantic.fields.ModelField"pydantic.fields.ModelField*
v
Any*c
valuesW
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dict*Ö
loc˚
OTypeAlias[Union[builtins.tuple[Union[builtins.int,builtins.str]],builtins.str]]ç
DUnion[builtins.tuple[Union[builtins.int,builtins.str]],builtins.str]§
0builtins.tuple[Union[builtins.int,builtins.str]]`
 Union[builtins.int,builtins.str]
builtins.int"builtins.int
builtins.str"builtins.str"builtins.tuple
builtins.str"builtins.str"pydantic.fields.LocStr*µ
cls´
NUnion[Type[pydantic.main.BaseModel],Type[pydantic.dataclasses.Dataclass],None][
Type[pydantic.main.BaseModel]2
pydantic.main.BaseModel"pydantic.main.BaseModel"typep
$Type[pydantic.dataclasses.Dataclass]@
pydantic.dataclasses.Dataclass"pydantic.dataclasses.Dataclass"type
None*•
_validate_tuple*pydantic.fields.ModelField._validate_tuple"Ï
gTypeAlias[Tuple[Union[Any,None],Union[typing.Sequence[Any],pydantic.error_wrappers.ErrorWrapper,None]]]ﬁ
\Tuple[Union[Any,None],Union[typing.Sequence[Any],pydantic.error_wrappers.ErrorWrapper,None]]&
Union[Any,None]
Any
None”
EUnion[typing.Sequence[Any],pydantic.error_wrappers.ErrorWrapper,None]0
typing.Sequence[Any]
Any"typing.SequenceL
$pydantic.error_wrappers.ErrorWrapper"$pydantic.error_wrappers.ErrorWrapper
None"pydantic.fields.ValidateReturn*B
self8
pydantic.fields.ModelField"pydantic.fields.ModelField*
v
Any*c
valuesW
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dict*Ö
loc˚
OTypeAlias[Union[builtins.tuple[Union[builtins.int,builtins.str]],builtins.str]]ç
DUnion[builtins.tuple[Union[builtins.int,builtins.str]],builtins.str]§
0builtins.tuple[Union[builtins.int,builtins.str]]`
 Union[builtins.int,builtins.str]
builtins.int"builtins.int
builtins.str"builtins.str"builtins.tuple
builtins.str"builtins.str"pydantic.fields.LocStr*µ
cls´
NUnion[Type[pydantic.main.BaseModel],Type[pydantic.dataclasses.Dataclass],None][
Type[pydantic.main.BaseModel]2
pydantic.main.BaseModel"pydantic.main.BaseModel"typep
$Type[pydantic.dataclasses.Dataclass]@
pydantic.dataclasses.Dataclass"pydantic.dataclasses.Dataclass"type
None*≥
_validate_mapping_like1pydantic.fields.ModelField._validate_mapping_like"Ï
gTypeAlias[Tuple[Union[Any,None],Union[typing.Sequence[Any],pydantic.error_wrappers.ErrorWrapper,None]]]ﬁ
\Tuple[Union[Any,None],Union[typing.Sequence[Any],pydantic.error_wrappers.ErrorWrapper,None]]&
Union[Any,None]
Any
None”
EUnion[typing.Sequence[Any],pydantic.error_wrappers.ErrorWrapper,None]0
typing.Sequence[Any]
Any"typing.SequenceL
$pydantic.error_wrappers.ErrorWrapper"$pydantic.error_wrappers.ErrorWrapper
None"pydantic.fields.ValidateReturn*B
self8
pydantic.fields.ModelField"pydantic.fields.ModelField*
v
Any*c
valuesW
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dict*Ö
loc˚
OTypeAlias[Union[builtins.tuple[Union[builtins.int,builtins.str]],builtins.str]]ç
DUnion[builtins.tuple[Union[builtins.int,builtins.str]],builtins.str]§
0builtins.tuple[Union[builtins.int,builtins.str]]`
 Union[builtins.int,builtins.str]
builtins.int"builtins.int
builtins.str"builtins.str"builtins.tuple
builtins.str"builtins.str"pydantic.fields.LocStr*µ
cls´
NUnion[Type[pydantic.main.BaseModel],Type[pydantic.dataclasses.Dataclass],None][
Type[pydantic.main.BaseModel]2
pydantic.main.BaseModel"pydantic.main.BaseModel"typep
$Type[pydantic.dataclasses.Dataclass]@
pydantic.dataclasses.Dataclass"pydantic.dataclasses.Dataclass"type
None*Ë
_get_mapping_value-pydantic.fields.ModelField._get_mapping_value"∫
/Union[pydantic.fields.T,builtins.dict[Any,Any]]J
pydantic.fields.T"
builtins.object"builtins.object"builtins.object9
builtins.dict[Any,Any]
Any
Any"builtins.dict*B
self8
pydantic.fields.ModelField"pydantic.fields.ModelField*X
originalJ
pydantic.fields.T"
builtins.object"builtins.object"builtins.object*H
	converted9
builtins.dict[Any,Any]
Any
Any"builtins.dict*≠
_validate_singleton.pydantic.fields.ModelField._validate_singleton"Ï
gTypeAlias[Tuple[Union[Any,None],Union[typing.Sequence[Any],pydantic.error_wrappers.ErrorWrapper,None]]]ﬁ
\Tuple[Union[Any,None],Union[typing.Sequence[Any],pydantic.error_wrappers.ErrorWrapper,None]]&
Union[Any,None]
Any
None”
EUnion[typing.Sequence[Any],pydantic.error_wrappers.ErrorWrapper,None]0
typing.Sequence[Any]
Any"typing.SequenceL
$pydantic.error_wrappers.ErrorWrapper"$pydantic.error_wrappers.ErrorWrapper
None"pydantic.fields.ValidateReturn*B
self8
pydantic.fields.ModelField"pydantic.fields.ModelField*
v
Any*c
valuesW
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dict*Ö
loc˚
OTypeAlias[Union[builtins.tuple[Union[builtins.int,builtins.str]],builtins.str]]ç
DUnion[builtins.tuple[Union[builtins.int,builtins.str]],builtins.str]§
0builtins.tuple[Union[builtins.int,builtins.str]]`
 Union[builtins.int,builtins.str]
builtins.int"builtins.int
builtins.str"builtins.str"builtins.tuple
builtins.str"builtins.str"pydantic.fields.LocStr*µ
cls´
NUnion[Type[pydantic.main.BaseModel],Type[pydantic.dataclasses.Dataclass],None][
Type[pydantic.main.BaseModel]2
pydantic.main.BaseModel"pydantic.main.BaseModel"typep
$Type[pydantic.dataclasses.Dataclass]@
pydantic.dataclasses.Dataclass"pydantic.dataclasses.Dataclass"type
None*¡
_validate_discriminated_union8pydantic.fields.ModelField._validate_discriminated_union"Ï
gTypeAlias[Tuple[Union[Any,None],Union[typing.Sequence[Any],pydantic.error_wrappers.ErrorWrapper,None]]]ﬁ
\Tuple[Union[Any,None],Union[typing.Sequence[Any],pydantic.error_wrappers.ErrorWrapper,None]]&
Union[Any,None]
Any
None”
EUnion[typing.Sequence[Any],pydantic.error_wrappers.ErrorWrapper,None]0
typing.Sequence[Any]
Any"typing.SequenceL
$pydantic.error_wrappers.ErrorWrapper"$pydantic.error_wrappers.ErrorWrapper
None"pydantic.fields.ValidateReturn*B
self8
pydantic.fields.ModelField"pydantic.fields.ModelField*
v
Any*c
valuesW
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dict*Ö
loc˚
OTypeAlias[Union[builtins.tuple[Union[builtins.int,builtins.str]],builtins.str]]ç
DUnion[builtins.tuple[Union[builtins.int,builtins.str]],builtins.str]§
0builtins.tuple[Union[builtins.int,builtins.str]]`
 Union[builtins.int,builtins.str]
builtins.int"builtins.int
builtins.str"builtins.str"builtins.tuple
builtins.str"builtins.str"pydantic.fields.LocStr*µ
cls´
NUnion[Type[pydantic.main.BaseModel],Type[pydantic.dataclasses.Dataclass],None][
Type[pydantic.main.BaseModel]2
pydantic.main.BaseModel"pydantic.main.BaseModel"typep
$Type[pydantic.dataclasses.Dataclass]@
pydantic.dataclasses.Dataclass"pydantic.dataclasses.Dataclass"type
None*ß
_apply_validators,pydantic.fields.ModelField._apply_validators"Ï
gTypeAlias[Tuple[Union[Any,None],Union[typing.Sequence[Any],pydantic.error_wrappers.ErrorWrapper,None]]]ﬁ
\Tuple[Union[Any,None],Union[typing.Sequence[Any],pydantic.error_wrappers.ErrorWrapper,None]]&
Union[Any,None]
Any
None”
EUnion[typing.Sequence[Any],pydantic.error_wrappers.ErrorWrapper,None]0
typing.Sequence[Any]
Any"typing.SequenceL
$pydantic.error_wrappers.ErrorWrapper"$pydantic.error_wrappers.ErrorWrapper
None"pydantic.fields.ValidateReturn*B
self8
pydantic.fields.ModelField"pydantic.fields.ModelField*
v
Any*c
valuesW
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dict*Ö
loc˚
OTypeAlias[Union[builtins.tuple[Union[builtins.int,builtins.str]],builtins.str]]ç
DUnion[builtins.tuple[Union[builtins.int,builtins.str]],builtins.str]§
0builtins.tuple[Union[builtins.int,builtins.str]]`
 Union[builtins.int,builtins.str]
builtins.int"builtins.int
builtins.str"builtins.str"builtins.tuple
builtins.str"builtins.str"pydantic.fields.LocStr*µ
cls´
NUnion[Type[pydantic.main.BaseModel],Type[pydantic.dataclasses.Dataclass],None][
Type[pydantic.main.BaseModel]2
pydantic.main.BaseModel"pydantic.main.BaseModel"typep
$Type[pydantic.dataclasses.Dataclass]@
pydantic.dataclasses.Dataclass"pydantic.dataclasses.Dataclass"type
None*˚

validatorsÍ
DTypeAlias[builtins.list[TypeAlias[CallableType[builtins.function]]]]ı
9builtins.list[TypeAlias[CallableType[builtins.function]]]®
*TypeAlias[CallableType[builtins.function]]K
CallableType[builtins.function]&
builtins.function"builtins.function"+pydantic.class_validators.ValidatorCallable"builtins.list"(pydantic.class_validators.ValidatorsList*ó

is_complex%pydantic.fields.ModelField.is_complex"
builtins.bool"builtins.bool*B
self8
pydantic.fields.ModelField"pydantic.fields.ModelField*∑
_type_display(pydantic.fields.ModelField._type_display"8
pydantic.utils.PyObjectStr"pydantic.utils.PyObjectStr*B
self8
pydantic.fields.ModelField"pydantic.fields.ModelField*ü
__repr_args__(pydantic.fields.ModelField.__repr_args__"ü
?TypeAlias[typing.Sequence[Tuple[Union[builtins.str,None],Any]]]ø
4typing.Sequence[Tuple[Union[builtins.str,None],Any]]v
#Tuple[Union[builtins.str,None],Any]D
Union[builtins.str,None]
builtins.str"builtins.str
None
Any"typing.Sequence"pydantic.typing.ReprArgs*B
self8
pydantic.fields.ModelField"pydantic.fields.ModelFieldrú
	__slots__$pydantic.fields.ModelField.__slots__Ë
±Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]
builtins.str"builtins.str
builtins.str"builtins.str
builtins.str"builtins.str
builtins.str"builtins.str
builtins.str"builtins.str
builtins.str"builtins.str
builtins.str"builtins.str
builtins.str"builtins.str
builtins.str"builtins.str
builtins.str"builtins.str
builtins.str"builtins.str
builtins.str"builtins.str
builtins.str"builtins.str
builtins.str"builtins.str
builtins.str"builtins.str
builtins.str"builtins.str
builtins.str"builtins.str
builtins.str"builtins.str
builtins.str"builtins.str
builtins.str"builtins.str
builtins.str"builtins.str
builtins.str"builtins.str
builtins.str"builtins.strrE
namepydantic.fields.ModelField.name
builtins.str"builtins.strrQ
	has_alias$pydantic.fields.ModelField.has_alias
builtins.bool"builtins.boolrG
alias pydantic.fields.ModelField.alias
builtins.str"builtins.strr2
type_ pydantic.fields.ModelField.type_
Anyr>
outer_type_&pydantic.fields.ModelField.outer_type_
Anyr¸
class_validators+pydantic.fields.ModelField.class_validators∫
?builtins.dict[builtins.str,pydantic.class_validators.Validator]
builtins.str"builtins.strJ
#pydantic.class_validators.Validator"#pydantic.class_validators.Validator"builtins.dictr6
default"pydantic.fields.ModelField.default
Anyr§
default_factory*pydantic.fields.ModelField.default_factory‰
6Union[TypeAlias[CallableType[builtins.function]],None]ù
*TypeAlias[CallableType[builtins.function]]K
CallableType[builtins.function]&
builtins.function"builtins.function" pydantic.typing.NoArgAnyCallable
Noner´
required#pydantic.fields.ModelField.required˘
=TypeAlias[Union[builtins.bool,pydantic.fields.UndefinedType]]ñ
2Union[builtins.bool,pydantic.fields.UndefinedType]
builtins.bool"builtins.bool>
pydantic.fields.UndefinedType"pydantic.fields.UndefinedType"pydantic.fields.BoolUndefinedrù
model_config'pydantic.fields.ModelField.model_configd
 Type[pydantic.config.BaseConfig]8
pydantic.config.BaseConfig"pydantic.config.BaseConfig"typerk

field_info%pydantic.fields.ModelField.field_info6
pydantic.fields.FieldInfo"pydantic.fields.FieldInforá
discriminator_key,pydantic.fields.ModelField.discriminator_keyD
Union[builtins.str,None]
builtins.str"builtins.str
Nonerã
discriminator_alias.pydantic.fields.ModelField.discriminator_aliasD
Union[builtins.str,None]
builtins.str"builtins.str
NonerS

allow_none%pydantic.fields.ModelField.allow_none
builtins.bool"builtins.boolr]
validate_always*pydantic.fields.ModelField.validate_always
builtins.bool"builtins.boolrÔ

sub_fields%pydantic.fields.ModelField.sub_fieldsπ
5Union[builtins.list[pydantic.fields.ModelField],None]t
)builtins.list[pydantic.fields.ModelField]8
pydantic.fields.ModelField"pydantic.fields.ModelField"builtins.list
Noner∏
sub_fields_mapping-pydantic.fields.ModelField.sub_fields_mappingÚ
BUnion[builtins.dict[builtins.str,pydantic.fields.ModelField],None]ü
6builtins.dict[builtins.str,pydantic.fields.ModelField]
builtins.str"builtins.str8
pydantic.fields.ModelField"pydantic.fields.ModelField"builtins.dict
Noner°
	key_field$pydantic.fields.ModelField.key_fieldn
&Union[pydantic.fields.ModelField,None]8
pydantic.fields.ModelField"pydantic.fields.ModelField
Noner†

validators%pydantic.fields.ModelField.validatorsÍ
DTypeAlias[builtins.list[TypeAlias[CallableType[builtins.function]]]]ı
9builtins.list[TypeAlias[CallableType[builtins.function]]]®
*TypeAlias[CallableType[builtins.function]]K
CallableType[builtins.function]&
builtins.function"builtins.function"+pydantic.class_validators.ValidatorCallable"builtins.list"(pydantic.class_validators.ValidatorsListrâ
pre_validators)pydantic.fields.ModelField.pre_validatorsÀ
PUnion[TypeAlias[builtins.list[TypeAlias[CallableType[builtins.function]]]],None]Í
DTypeAlias[builtins.list[TypeAlias[CallableType[builtins.function]]]]ı
9builtins.list[TypeAlias[CallableType[builtins.function]]]®
*TypeAlias[CallableType[builtins.function]]K
CallableType[builtins.function]&
builtins.function"builtins.function"+pydantic.class_validators.ValidatorCallable"builtins.list"(pydantic.class_validators.ValidatorsList
Nonerã
post_validators*pydantic.fields.ModelField.post_validatorsÀ
PUnion[TypeAlias[builtins.list[TypeAlias[CallableType[builtins.function]]]],None]Í
DTypeAlias[builtins.list[TypeAlias[CallableType[builtins.function]]]]ı
9builtins.list[TypeAlias[CallableType[builtins.function]]]®
*TypeAlias[CallableType[builtins.function]]K
CallableType[builtins.function]&
builtins.function"builtins.function"+pydantic.class_validators.ValidatorCallable"builtins.list"(pydantic.class_validators.ValidatorsList
NonerS

parse_json%pydantic.fields.ModelField.parse_json
builtins.bool"builtins.boolrG
shape pydantic.fields.ModelField.shape
builtins.int"builtins.int¡

ModelPrivateAttr pydantic.fields.ModelPrivateAttr"pydantic.utils.Representation*¶
__init__)pydantic.fields.ModelPrivateAttr.__init__"
None*N
selfD
 pydantic.fields.ModelPrivateAttr" pydantic.fields.ModelPrivateAttr*
default
Any *¸
default_factory‰
6Union[TypeAlias[CallableType[builtins.function]],None]ù
*TypeAlias[CallableType[builtins.function]]K
CallableType[builtins.function]&
builtins.function"builtins.function" pydantic.typing.NoArgAnyCallable
None *î
get_default,pydantic.fields.ModelPrivateAttr.get_default"
Any*N
selfD
 pydantic.fields.ModelPrivateAttr" pydantic.fields.ModelPrivateAttr*§
__eq__'pydantic.fields.ModelPrivateAttr.__eq__"
builtins.bool"builtins.bool*FD
 pydantic.fields.ModelPrivateAttr" pydantic.fields.ModelPrivateAttr*	
Anyrô
	__slots__*pydantic.fields.ModelPrivateAttr.__slots__`
 Tuple[builtins.str,builtins.str]
builtins.str"builtins.str
builtins.str"builtins.strr<
default(pydantic.fields.ModelPrivateAttr.default
Anyr™
default_factory0pydantic.fields.ModelPrivateAttr.default_factory‰
6Union[TypeAlias[CallableType[builtins.function]],None]ù
*TypeAlias[CallableType[builtins.function]]K
CallableType[builtins.function]&
builtins.function"builtins.function" pydantic.typing.NoArgAnyCallable
None=
DeferredTypepydantic.fields.DeferredType"builtins.objectª
Fieldpydantic.fields.Field"
Any*
default
Any *¸
default_factory‰
6Union[TypeAlias[CallableType[builtins.function]],None]ù
*TypeAlias[CallableType[builtins.function]]K
CallableType[builtins.function]&
builtins.function"builtins.function" pydantic.typing.NoArgAnyCallable
None *)
alias
builtins.str"builtins.str *)
title
builtins.str"builtins.str */
description
builtins.str"builtins.str *ö
excludeä
|Union[TypeAlias[typing.AbstractSet[TypeAlias[Union[builtins.int,builtins.str]]]],TypeAlias[typing.Mapping[Unknown,Any]],Any]ı
JTypeAlias[typing.AbstractSet[TypeAlias[Union[builtins.int,builtins.str]]]]Å
?typing.AbstractSet[TypeAlias[Union[builtins.int,builtins.str]]]©
+TypeAlias[Union[builtins.int,builtins.str]]`
 Union[builtins.int,builtins.str]
builtins.int"builtins.int
builtins.str"builtins.str"pydantic.typing.IntStr"typing.AbstractSet"!pydantic.typing.AbstractSetIntStrÜ
&TypeAlias[typing.Mapping[Unknown,Any]]8
typing.Mapping[Unknown,Any] 
Any"typing.Mapping" pydantic.typing.MappingIntStrAny
Any *ö
includeä
|Union[TypeAlias[typing.AbstractSet[TypeAlias[Union[builtins.int,builtins.str]]]],TypeAlias[typing.Mapping[Unknown,Any]],Any]ı
JTypeAlias[typing.AbstractSet[TypeAlias[Union[builtins.int,builtins.str]]]]Å
?typing.AbstractSet[TypeAlias[Union[builtins.int,builtins.str]]]©
+TypeAlias[Union[builtins.int,builtins.str]]`
 Union[builtins.int,builtins.str]
builtins.int"builtins.int
builtins.str"builtins.str"pydantic.typing.IntStr"typing.AbstractSet"!pydantic.typing.AbstractSetIntStrÜ
&TypeAlias[typing.Mapping[Unknown,Any]]8
typing.Mapping[Unknown,Any] 
Any"typing.Mapping" pydantic.typing.MappingIntStrAny
Any *+
const
builtins.bool"builtins.bool **
gt 
builtins.float"builtins.float **
ge 
builtins.float"builtins.float **
lt 
builtins.float"builtins.float **
le 
builtins.float"builtins.float *3
multiple_of 
builtins.float"builtins.float *.

max_digits
builtins.int"builtins.int *2
decimal_places
builtins.int"builtins.int *-
	min_items
builtins.int"builtins.int *-
	max_items
builtins.int"builtins.int *2
unique_items
builtins.bool"builtins.bool *.

min_length
builtins.int"builtins.int *.

max_length
builtins.int"builtins.int *4
allow_mutation
builtins.bool"builtins.bool *)
regex
builtins.str"builtins.str *1
discriminator
builtins.str"builtins.str **
repr
builtins.bool"builtins.bool *
extra
Any 
PrivateAttrpydantic.fields.PrivateAttr"
Any*
default
Any *¸
default_factory‰
6Union[TypeAlias[CallableType[builtins.function]],None]ù
*TypeAlias[CallableType[builtins.function]]K
CallableType[builtins.function]&
builtins.function"builtins.function" pydantic.typing.NoArgAnyCallable
None *ã
__annotations__pydantic.fields.__annotations__W
builtins.dict[builtins.str,Any]
builtins.str"builtins.str
Any"builtins.dict*
errors_pydantic.errors *-
Requiredpydantic.fields.Required
Any*f
	Undefinedpydantic.fields.Undefined>
pydantic.fields.UndefinedType"pydantic.fields.UndefinedType*P
SHAPE_SINGLETONpydantic.fields.SHAPE_SINGLETON
builtins.int"builtins.int*F

SHAPE_LISTpydantic.fields.SHAPE_LIST
builtins.int"builtins.int*D
	SHAPE_SETpydantic.fields.SHAPE_SET
builtins.int"builtins.int*L
SHAPE_MAPPINGpydantic.fields.SHAPE_MAPPING
builtins.int"builtins.int*H
SHAPE_TUPLEpydantic.fields.SHAPE_TUPLE
builtins.int"builtins.int*Z
SHAPE_TUPLE_ELLIPSIS$pydantic.fields.SHAPE_TUPLE_ELLIPSIS
builtins.int"builtins.int*N
SHAPE_SEQUENCEpydantic.fields.SHAPE_SEQUENCE
builtins.int"builtins.int*P
SHAPE_FROZENSETpydantic.fields.SHAPE_FROZENSET
builtins.int"builtins.int*N
SHAPE_ITERABLEpydantic.fields.SHAPE_ITERABLE
builtins.int"builtins.int*L
SHAPE_GENERICpydantic.fields.SHAPE_GENERIC
builtins.int"builtins.int*H
SHAPE_DEQUEpydantic.fields.SHAPE_DEQUE
builtins.int"builtins.int*F

SHAPE_DICTpydantic.fields.SHAPE_DICT
builtins.int"builtins.int*T
SHAPE_DEFAULTDICT!pydantic.fields.SHAPE_DEFAULTDICT
builtins.int"builtins.int*L
SHAPE_COUNTERpydantic.fields.SHAPE_COUNTER
builtins.int"builtins.int*≠
SHAPE_NAME_LOOKUP!pydantic.fields.SHAPE_NAME_LOOKUPu
(builtins.dict[builtins.int,builtins.str]
builtins.int"builtins.int
builtins.str"builtins.str"builtins.dict*Ñ
MAPPING_LIKE_SHAPES#pydantic.fields.MAPPING_LIKE_SHAPESH
builtins.set[builtins.int]
builtins.int"builtins.int"builtins.set